/*************************************** === 삼중등호연산자 *******************************************/
/*************************************** == 이중등호연산자 *******************************************/
'hi' === 'hi' // true
['hi', 'bye'] === ['hi', 'bye'] // false
   [1] === [1] // false
   [1] == [1] // false
   [] == [] // false

// js는 배열 안에 뭐가 있던 상관안함
// 실제로 비교하는것 = 메모리에서 참조되는 값

// 일정량의 메모리 공간이 이 숫자에 할당됨. 
// 모든 숫자라면 일정 메모리 공간을 차지함. 숫자마다 최대 크기가 있음.
let luckyNum = 87;
0.9999999999999

// 하지만 배열은 다른 경우임.
// 열개의 숫자가 있는 배열, 1만개의 숫자가 있는 배열, 1만개의 문자열을 넣어 많은 공간 차지 가능 

// 배열 안에 임의의 숫자를 넣으면 js는 이 배열의 콘텐츠와 행운의 숫자를 연관짓지 않음
// 콘텐츠는 바뀔수 있고 얼마나 공간을 차지할지 모르니까 배열안에 저장되는건 참조이다.
// 우리 눈에 보이지 않는 곳에서 이 배열은 집주소나 주민등록번호처럼 작용한다.
let luckyNums = [2, 34, 89];

// 메모리에서 이 배열을 생성. 이 배열의 고유한 주소인 참조를 갖는다.
[1, 2, 3]

// 또 다른 [1,2,3]을 만들면 새로운 배열이 생성되고 새로운 주민등록번호가 생성된다.
[1, 2, 3]

// 두 배열은 콘텐츠는 같지만, 메모리에서 다른것을 참조하므로 차이가 있다.
[1, 2, 3] === [1, 2, 3]

// nums와 numsCopy는 같은 메모리를 참조. 
// 새 배열을 만든게 아니라 nums가 이 배열과 같다고 한 후 같은걸 따르는 새 변수를 생성
// 하나를 바꾸면 다른것도 같이 바뀜.
// 같은 참조를 비교하기 때문에 삼중등호연산자 === true

let nums = [1, 2, 3]
let numsCopy = nums
nums // 1,2,3
numsCopy // 1,2,3
nums.push(4) // 1,2,3,4
numsCopy // 1,2,3,4,
numsCopy.pop() // 1,2,3
nums // 1,2,3 -> 반대로도 같이 작용
nums === numsCopy // true

// JavaScript에서 배열을 비교하려면 같은 참조를 따르는 배열인지 확인해야 한다.
// 콘텐츠를 비교할 때는 소용이 없다.


